<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GitHub Multiplayer Cube Game</title>
<style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #waiting-popup {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        color: red;
        font-size: 20px;
        font-weight: bold;
        display: none;
        z-index: 10;
    }
</style>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
</head>
<body>
<div id="waiting-popup">Waiting for an available slot...</div>

<script>
const API_BASE = 'https://node-weaver--Zapt0rWut.replit.app'; // your backend

let scene, camera, renderer, playerCube;
let localPlayer = { id: Math.random().toString(36).substr(2,9), name: "You", color: Math.random() * 0xffffff };
let players = {};
let otherPlayers = {};
let nameTags = {};
let yaw = 0, pitch = 0, euler = new THREE.Euler(0,0,0,'YXZ');
let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false, jump=false;
let velocity = new THREE.Vector3(), onGround = false;
const moveSpeed = 0.1, gravity = -0.05, jumpHeight = 0.7;

let ws;

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0,1,0);

    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const floor = new THREE.Mesh(new THREE.PlaneGeometry(100,100), new THREE.MeshBasicMaterial({color:0x808080}));
    floor.rotation.x = -Math.PI/2;
    scene.add(floor);

    playerCube = new THREE.Mesh(new THREE.BoxGeometry(2,2,2), new THREE.MeshBasicMaterial({color: localPlayer.color}));
    scene.add(playerCube);

    nameTags[localPlayer.id] = createNameTag(localPlayer.name);
    scene.add(nameTags[localPlayer.id]);

    connectWS();

    document.body.addEventListener("click",()=>document.body.requestPointerLock());
    document.addEventListener("mousemove",onMouseMove);
    document.addEventListener("keydown",onKeyDown);
    document.addEventListener("keyup",onKeyUp);

    animate();
}

function onMouseMove(e){
    if(document.pointerLockElement !== document.body) return;
    yaw -= e.movementX*0.002;
    pitch -= e.movementY*0.002;
    pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
    euler.set(pitch,yaw,0);
    camera.quaternion.setFromEuler(euler);
}

function onKeyDown(e){
    if(e.key==='w') moveForward=true;
    if(e.key==='s') moveBackward=true;
    if(e.key==='a') moveLeft=true;
    if(e.key==='d') moveRight=true;
    if(e.key===' ') jump=true;
}

function onKeyUp(e){
    if(e.key==='w') moveForward=false;
    if(e.key==='s') moveBackward=false;
    if(e.key==='a') moveLeft=false;
    if(e.key==='d') moveRight=false;
    if(e.key===' ') jump=false;
}

function createNameTag(text){
    const canvas=document.createElement('canvas');
    canvas.width=256; canvas.height=64;
    const ctx=canvas.getContext('2d');
    ctx.fillStyle='white'; ctx.font='28px monospace'; ctx.textAlign='center';
    ctx.fillText(text,128,40);
    const tex=new THREE.CanvasTexture(canvas);
    const sprite=new THREE.Sprite(new THREE.SpriteMaterial({map:tex}));
    sprite.scale.set(2,1,1);
    return sprite;
}

function updateLocalMovement(){
    const direction = new THREE.Vector3();
    const forward = new THREE.Vector3(); camera.getWorldDirection(forward); forward.y=0; forward.normalize();
    const right = new THREE.Vector3(); right.crossVectors(camera.up, forward); right.normalize();
    if(moveForward) direction.addScaledVector(forward, moveSpeed);
    if(moveBackward) direction.addScaledVector(forward, -moveSpeed);
    if(moveLeft) direction.addScaledVector(right, moveSpeed);
    if(moveRight) direction.addScaledVector(right, -moveSpeed);
    camera.position.add(direction);
    playerCube.position.copy(camera.position);
    if(jump && onGround){ velocity.y = jumpHeight; onGround=false; }
    velocity.y += gravity; camera.position.y += velocity.y;
    if(camera.position.y <=1){ camera.position.y=1; velocity.y=0; onGround=true; }
}

function updateNameTags(){
    for(let id in nameTags){
        const target = (id===localPlayer.id)?playerCube:otherPlayers[id];
        if(target) nameTags[id].position.set(target.position.x, target.position.y+1.5, target.position.z);
    }
}

function animate(){
    requestAnimationFrame(animate);
    updateLocalMovement();
    updateNameTags();
    sendUpdate();
    renderer.render(scene,camera);
}

function connectWS(){
    const protocol = location.protocol==='https:'?'wss':'ws';
    ws = new WebSocket(`${protocol}://${API_BASE.replace(/^https?:\/\//,'')}/ws`);
    ws.onopen = ()=> ws.send(JSON.stringify({type:'joinGame', id: localPlayer.id, name: localPlayer.name, color: localPlayer.color}));
    ws.onmessage = e => {
        const msg=JSON.parse(e.data);
        if(msg.type==='gameState'){
            msg.players.forEach(p=>{
                if(p.id!==localPlayer.id && !otherPlayers[p.id]){
                    const cube = new THREE.Mesh(new THREE.BoxGeometry(2,2,2), new THREE.MeshBasicMaterial({color:p.color}));
                    otherPlayers[p.id]=cube; scene.add(cube);
                    nameTags[p.id]=createNameTag(p.name); scene.add(nameTags[p.id]);
                }
                if(otherPlayers[p.id]){
                    otherPlayers[p.id].position.set(p.position.x,p.position.y,p.position.z);
                    const e = new THREE.Euler(p.rotation.pitch,p.rotation.yaw,0,'YXZ');
                    otherPlayers[p.id].rotation.set(e.x,e.y,e.z);
                }
            });
        }
        if(msg.type==='playerLeft'){
            const id=msg.id;
            if(otherPlayers[id]){ scene.remove(otherPlayers[id]); scene.remove(nameTags[id]); delete otherPlayers[id]; delete nameTags[id]; }
        }
    };
}

function sendUpdate(){
    if(!ws||ws.readyState!==1) return;
    ws.send(JSON.stringify({type:'update', id:localPlayer.id, position:camera.position, rotation:{yaw,pitch}}));
}

window.addEventListener("beforeunload", ()=>ws?.close());
init();
</script>
</body>
</html>
