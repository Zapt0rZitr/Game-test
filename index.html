<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GitHub Multiplayer Cube Game</title>
<style>
    body { margin:0; overflow:hidden; font-family: sans-serif; }
    canvas { display:block; }
    #ui { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:#111; color:white; }
    .card { background:#1f1f1f; padding:2rem; border-radius:8px; width:300px; }
    input, button { width:100%; margin-top:0.75rem; padding:0.6rem; font-size:1rem; }
    button { background:#2563eb; border:none; color:white; cursor:pointer; }
    button:hover { background:#1d4ed8; }
    #overlay { position:absolute; top:10px; left:10px; color:white; z-index:10; display:none; }
</style>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
</head>
<body>
<div id="ui"></div>
<div id="overlay">Click to lock mouse | WASD to move | Space to jump</div>

<script>
const API_BASE = 'https://node-weaver--Zapt0rWut.replit.app';

let currentPlayer = null;
let ws = null;
let players = {};
let otherPlayers = {};
let nameTags = {};
let scene, camera, renderer;
let localCube;
let yaw=0, pitch=0, euler=new THREE.Euler(0,0,0,'YXZ');
let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false, jump=false;
let velocity=new THREE.Vector3(), onGround=false;
const moveSpeed=0.1, gravity=-0.05, jumpHeight=0.7;

/* ========== UI / Lobby ========== */
function renderUI(){
    const ui = document.getElementById("ui");
    if(!currentPlayer){
        ui.innerHTML = `
            <div class="card">
                <h2>Enter Username</h2>
                <input id="username" placeholder="Username" />
                <button onclick="joinGame()">Join</button>
            </div>
        `;
    } else {
        ui.style.display="none";
        document.getElementById("overlay").style.display="block";
        initGame();
    }
}

async function joinGame(){
    const name = document.getElementById("username").value.trim();
    if(!name) return;
    try {
        const res = await fetch(`${API_BASE}/api/players`, {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body: JSON.stringify({name})
        });
        if(res.status===409){ alert("Name taken"); return; }
        if(!res.ok) throw new Error("Join failed");
        currentPlayer = await res.json();
        renderUI();
    } catch(e){ console.error(e); alert("Failed to join"); }
}

/* ========== Game Initialization ========== */
function initGame(){
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);

    camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0,1.6,0);

    renderer = new THREE.WebGLRenderer();
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    const floor = new THREE.Mesh(new THREE.PlaneGeometry(100,100), new THREE.MeshBasicMaterial({color:0x808080}));
    floor.rotation.x=-Math.PI/2;
    scene.add(floor);

    localCube = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshBasicMaterial({color:currentPlayer.color}));
    scene.add(localCube);
    nameTags[currentPlayer.id] = createNameTag(currentPlayer.name);
    scene.add(nameTags[currentPlayer.id]);

    connectWS();

    document.body.addEventListener("click",()=>document.body.requestPointerLock());
    document.addEventListener("mousemove",onMouseMove);
    document.addEventListener("keydown",onKeyDown);
    document.addEventListener("keyup",onKeyUp);

    animate();
}

/* ========== Controls ========== */
function onMouseMove(e){
    if(document.pointerLockElement!==document.body) return;
    yaw-=e.movementX*0.002;
    pitch-=e.movementY*0.002;
    pitch=Math.max(-Math.PI/2, Math.min(Math.PI/2,pitch));
    euler.set(pitch,yaw,0);
    camera.quaternion.setFromEuler(euler);
}

function onKeyDown(e){
    if(e.key==='w') moveForward=true;
    if(e.key==='s') moveBackward=true;
    if(e.key==='a') moveLeft=true;
    if(e.key==='d') moveRight=true;
    if(e.key===' ') jump=true;
}

function onKeyUp(e){
    if(e.key==='w') moveForward=false;
    if(e.key==='s') moveBackward=false;
    if(e.key==='a') moveLeft=false;
    if(e.key==='d') moveRight=false;
    if(e.key===' ') jump=false;
}

/* ========== Name Tags ========== */
function createNameTag(text){
    const canvas = document.createElement("canvas");
    canvas.width=256; canvas.height=64;
    const ctx = canvas.getContext("2d");
    ctx.fillStyle="white"; ctx.font="28px monospace"; ctx.textAlign="center";
    ctx.fillText(text,128,40);
    const tex = new THREE.CanvasTexture(canvas);
    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map:tex}));
    sprite.scale.set(2,0.5,1);
    return sprite;
}

function updateNameTags(){
    for(let id in nameTags){
        const target = (id===currentPlayer.id)?localCube:otherPlayers[id];
        if(target) nameTags[id].position.set(target.position.x,target.position.y+1.2,target.position.z);
    }
}

/* ========== Multiplayer WS ========== */
function connectWS(){
    const protocol = location.protocol==='https:'?'wss':'ws';
    ws = new WebSocket(`${protocol}://${API_BASE.replace(/^https?:\/\//,'')}/ws`);
    ws.onopen = ()=>{
        ws.send(JSON.stringify({type:'joinGame', id:currentPlayer.id, name:currentPlayer.name, color:currentPlayer.color}));
    };
    ws.onmessage = e=>{
        const msg=JSON.parse(e.data);
        if(msg.type==='gameState'){
            msg.players.forEach(p=>{
                if(p.id!==currentPlayer.id && !otherPlayers[p.id]){
                    const cube = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshBasicMaterial({color:p.color}));
                    otherPlayers[p.id]=cube; scene.add(cube);
                    nameTags[p.id] = createNameTag(p.name); scene.add(nameTags[p.id]);
                }
                if(otherPlayers[p.id]){
                    otherPlayers[p.id].position.set(p.position.x,p.position.y,p.position.z);
                    otherPlayers[p.id].rotation.set(p.rotation.pitch,p.rotation.yaw,0);
                }
            });
        }
        if(msg.type==='playerLeft'){
            const id = msg.id;
            if(otherPlayers[id]) { scene.remove(otherPlayers[id]); scene.remove(nameTags[id]); delete otherPlayers[id]; delete nameTags[id]; }
        }
    };
}

function sendUpdate(){
    if(!ws||ws.readyState!==1) return;
    ws.send(JSON.stringify({type:'update', id:currentPlayer.id, position:camera.position, rotation:{yaw,pitch}}));
}

/* ========== Movement ========== */
function updateMovement(){
    const dir = new THREE.Vector3();
    const forward = new THREE.Vector3(); camera.getWorldDirection(forward); forward.y=0; forward.normalize();
    const right = new THREE.Vector3(); right.crossVectors(camera.up, forward); right.normalize();
    if(moveForward) dir.addScaledVector(forward, moveSpeed);
    if(moveBackward) dir.addScaledVector(forward, -moveSpeed);
    if(moveLeft) dir.addScaledVector(right, -moveSpeed);
    if(moveRight) dir.addScaledVector(right, moveSpeed);
    camera.position.add(dir);
    localCube.position.copy(camera.position);
    if(jump && onGround){ velocity.y=jumpHeight; onGround=false; }
    velocity.y+=gravity; camera.position.y+=velocity.y;
    if(camera.position.y<=1){ camera.position.y=1; velocity.y=0; onGround=true; }
}

/* ========== Loop ========== */
function animate(){
    requestAnimationFrame(animate);
    updateMovement();
    updateNameTags();
    sendUpdate();
    renderer.render(scene,camera);
}

/* ========== Start ========== */
renderUI();
window.addEventListener("beforeunload",()=>ws?.close());
</script>
</body>
</html>
